[toc]

# 高并发

## 消息队列

### 应用

1. 场景（架构、代码）

	* 解耦（推送媒体发布状态；
	* 异步（多机房备份存储；转码；
	* 削峰（发博结果；

2. 问题

	* 增加依赖，降低可用性
	* 增加组件，提高复杂性
	* 一致性

3. 对比
	
	|   | 单机吞吐量 | topic数量对吞吐量的影响 | 时效性 | 可用性 | 可靠性 | 功能支持 | 社区活跃度 |
	| --- | --- | --- | --- | --- | --- | --- | --- |
	| Kafka | 10w | 几百topics时，吞吐量大幅度降低 | ms以内 | 非常高（分布式，多副本，少数及其宕机不丢失数据） | 优化参数后能不丢失 | 简单的MQ功能，主要用于大数据领域的实时计算及日志采集 | 极高 |
	| ActiveMQ | 1w |  | ms | 高（主从） | 较低概率丢失 | 功能极其完备 | 低 |
	| RabbitMQ | 1w |   | us | 高（主从） | 基本不丢 | 并发能力强，性能极好，延时很低（基于erlang） | 较高 |
	| RocketMQ | 10w | 几千topics时，吞吐量小幅度降低 | ms | 非常高（分布式） | 优化参数后能不丢失 | 功能完善，扩展性好 | 一般 |
	| MCQ |  |  |  |  |  |  |
	| Trigger |  |  |  |  |  |  |

### 原理及实现

#### 可用性

##### RabbitMQ可用性

RabbitMQ**基于主从**（非分布式）实现高可用。

RabbitMQ有三种模式：单机、普通集群、镜像集群。

1. 普通集群模式（无高可用）
	
	多台机器上启动多个实例，**创建的queue只放在一个实例上**，实例间同步queue的元数据，元数据记录了queue所在实例。消费时，如果本地实例没有需要的queue，则本地实例会从queue所在实例上拉取数据。
	
	使用时，消费者要么**随机连接一个实例并拉取数据**，要么**固定连接queue所在实例并消费数据**，前者有**数据拉取的开销**，后者有**单实例性能瓶颈**。
	
	由于queue单点，当queue所在实例宕机，会导致数据不可用，直到**持久化的数据所在的实例被恢复**。
	
	所以，普通集群模式能提高吞吐量，但没管高可用。
	
2. 镜像集群模式（高可用）

	多台机器上启动多个实例，**queue的元数据、消息同时存在于多个实例上**，即**每个实例都有queue的完整镜像**。生产消息时，会**自动同步消息到多个实例的queue**。
	
	由于多份完整镜像，**性能开销大**，**无法线性扩展**。
	
##### Kafka可用性

Kafka由多个broker组成，每个broker是一个节点。topic可以划分为多个partition，每个partition可以存放于不同的broker上，每个partition存放一部分数据。

Kafka是**分布式**


## 缓存

## 数据库

### 分库分表

### 读写分离

## 搜索引擎


# 分布式

## 系统拆分

## 分布式服务框架

## 分布式锁

## 分布式事务

## 分布式会话

# 高可用

## 隔离

## 限流

## 熔断

## 降级

# 微服务


